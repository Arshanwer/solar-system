<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Interactive 3D Solar System</title>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
		/>
		<style>
			body {
				margin: 0;
				overflow: hidden;
				background-color: #000;
				font-family: Arial, sans-serif;
				-webkit-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
				user-select: none;
			}
			canvas {
				display: block;
			}

			/* Clean header */
			.header {
				position: absolute;
				top: 10px;
				left: 50%;
				transform: translateX(-50%);
				text-align: center;
				color: #fff;
				font-size: 16px;
				font-weight: bold;
				text-shadow: 0 0 6px #000;
				z-index: 100;
			}

			/* Info popup button */
			.info-button {
				position: absolute;
				top: 20px;
				right: 20px;
				z-index: 101;
				width: 50px;
				height: 50px;
				background-color: rgba(0, 0, 0, 0.7);
				color: white;
				border: 1px solid white;
				border-radius: 50%;
				cursor: pointer;
				font-size: 20px;
				display: flex;
				align-items: center;
				justify-content: center;
				transition: background-color 0.3s;
			}

			.info-button:hover {
				background-color: rgba(255, 255, 255, 0.3);
			}

			/* Info popup */
			.info-popup {
				position: absolute;
				top: 80px;
				right: 20px;
				width: 350px;
				background-color: rgba(0, 0, 0, 0.9);
				color: white;
				padding: 20px;
				border-radius: 10px;
				border: 1px solid white;
				z-index: 102;
				display: none;
				font-size: 14px;
				box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
			}

			.info-popup h3 {
				margin: 0 0 15px 0;
				color: #8af;
				font-size: 18px;
			}

			.info-popup .close-btn {
				position: absolute;
				top: 10px;
				right: 15px;
				background: none;
				border: none;
				color: white;
				font-size: 24px;
				cursor: pointer;
				padding: 0;
				width: 30px;
				height: 30px;
				display: flex;
				align-items: center;
				justify-content: center;
			}

			.info-popup .close-btn:hover {
				color: #8af;
			}

			.info-popup a {
				color: #8af;
				text-decoration: none;
			}

			.info-popup a:hover {
				text-decoration: underline;
			}

			/* Left side controls */
			.left-controls {
				position: absolute;
				top: 20px;
				left: 20px;
				z-index: 101;
				display: flex;
				flex-direction: column;
				gap: 15px;
			}

			/* Time controls */
			.time-controls {
				background-color: rgba(0, 0, 0, 0.7);
				padding: 12px;
				border-radius: 5px;
				border: 1px solid white;
				max-width: 200px;
			}

			.time-controls h4 {
				margin: 0 0 10px 0;
				color: white;
				font-size: 14px;
			}

			.time-controls button {
				padding: 6px 12px;
				margin: 2px;
				font-size: 12px;
				background-color: rgba(0, 0, 0, 0.5);
				color: white;
				border: 1px solid #666;
				border-radius: 3px;
				cursor: pointer;
				min-width: 35px;
			}

			.time-controls button:hover {
				background-color: rgba(255, 255, 255, 0.3);
			}
			.time-controls button.active {
				background-color: rgba(255, 255, 255, 0.5);
			}

			.time-display {
				color: white;
				font-size: 12px;
				margin-top: 8px;
			}

			/* Shadow controls */
			.shadow-controls {
				background-color: rgba(0, 0, 0, 0.7);
				padding: 12px;
				border-radius: 5px;
				border: 1px solid white;
				max-width: 200px;
			}

			.shadow-controls h4 {
				margin: 0 0 10px 0;
				color: white;
				font-size: 14px;
			}

			.shadow-toggle {
				display: flex;
				align-items: center;
				gap: 10px;
				color: white;
				font-size: 12px;
			}

			.shadow-toggle input[type="checkbox"] {
				width: 20px;
				height: 20px;
				cursor: pointer;
			}

			/* Zoom controls */
			.zoom-controls {
				display: flex;
				flex-direction: column;
				gap: 8px;
			}

			.zoom-controls button {
				width: 50px;
				height: 50px;
				font-size: 20px;
				background-color: rgba(0, 0, 0, 0.7);
				color: white;
				border: 1px solid white;
				border-radius: 5px;
				cursor: pointer;
				transition: background-color 0.3s;
				user-select: none;
			}

			.zoom-controls button:hover {
				background-color: rgba(255, 255, 255, 0.3);
			}

			.zoom-controls button:active {
				background-color: rgba(255, 255, 255, 0.5);
			}

			/* Responsive controls panel */
			.controls-panel {
				position: absolute;
				bottom: 20px;
				left: 50%;
				transform: translateX(-50%);
				z-index: 101;
				display: flex;
				flex-wrap: wrap;
				justify-content: center;
				gap: 8px;
				width: 90%;
				max-width: 700px;
				padding: 0 10px;
				box-sizing: border-box;
			}

			.controls-panel button {
				padding: 10px 16px;
				font-size: 14px;
				background-color: rgba(0, 0, 0, 0.7);
				color: white;
				border: 1px solid white;
				border-radius: 5px;
				cursor: pointer;
				transition: background-color 0.3s;
				min-width: 80px;
				white-space: nowrap;
			}

			.controls-panel button:hover {
				background-color: rgba(255, 255, 255, 0.3);
			}
			.controls-panel button.active {
				background-color: rgba(255, 255, 255, 0.5);
			}

			/* Responsive information panel */
			.info-panel {
				position: absolute;
				bottom: 140px;
				left: 20px;
				width: 90%;
				max-width: 350px;
				background-color: rgba(0, 0, 0, 0.8);
				color: white;
				padding: 15px;
				border-radius: 8px;
				border: 1px solid white;
				z-index: 101;
				display: none;
				font-size: 14px;
				box-sizing: border-box;
			}

			.info-panel h3 {
				margin: 0 0 10px 0;
				color: #8af;
				font-size: 18px;
			}

			.info-panel .close-btn {
				position: absolute;
				top: 8px;
				right: 12px;
				background: none;
				border: none;
				color: white;
				font-size: 20px;
				cursor: pointer;
				padding: 0;
				width: 25px;
				height: 25px;
				display: flex;
				align-items: center;
				justify-content: center;
			}

			.info-panel .close-btn:hover {
				color: #8af;
			}

			/* Responsive distance indicator */
			.distance-indicator {
				position: absolute;
				bottom: 20px;
				right: 20px;
				background-color: rgba(0, 0, 0, 0.7);
				color: white;
				padding: 10px;
				border-radius: 5px;
				border: 1px solid white;
				font-size: 12px;
				z-index: 101;
				max-width: 200px;
			}

			/* Long press indicator */
			.long-press-indicator {
				position: absolute;
				pointer-events: none;
				border: 2px solid #8af;
				border-radius: 50%;
				background-color: rgba(136, 170, 255, 0.1);
				transform: translate(-50%, -50%);
				z-index: 102;
				display: none;
				transition: all 0.1s ease;
			}

			/* Mobile responsive styles */
			@media (max-width: 768px) {
				.header {
					font-size: 14px;
					top: 5px;
				}

				.info-button {
					top: 10px;
					right: 10px;
					width: 45px;
					height: 45px;
					font-size: 18px;
				}

				.info-popup {
					top: 65px;
					right: 10px;
					left: 10px;
					width: auto;
					font-size: 12px;
				}

				.left-controls {
					top: 10px;
					left: 10px;
					gap: 10px;
				}

				.time-controls,
				.shadow-controls {
					padding: 8px;
					max-width: 150px;
				}

				.time-controls h4,
				.shadow-controls h4 {
					font-size: 12px;
				}

				.time-controls button {
					padding: 4px 8px;
					font-size: 10px;
					min-width: 30px;
				}

				.zoom-controls button {
					width: 40px;
					height: 40px;
					font-size: 16px;
				}

				.controls-panel {
					bottom: 10px;
					gap: 6px;
				}

				.controls-panel button {
					padding: 8px 12px;
					font-size: 12px;
					min-width: 70px;
				}

				.info-panel {
					bottom: 80px;
					left: 10px;
					right: 10px;
					width: auto;
					max-width: none;
					font-size: 12px;
					max-height: 250px;
					overflow-y: auto;
				}

				.info-panel h3 {
					font-size: 16px;
					margin: 0 0 8px 0;
				}

				.distance-indicator {
					display: none;
				}
			}

			/* Small mobile devices */
			@media (max-width: 480px) {
				.controls-panel {
					flex-direction: column;
					align-items: center;
					width: 95%;
				}

				.controls-panel button {
					width: 100%;
					max-width: 200px;
				}

				.time-controls,
				.shadow-controls {
					max-width: 120px;
				}

				.time-controls button {
					padding: 3px 6px;
					margin: 1px;
					font-size: 9px;
				}

				.zoom-controls button {
					width: 35px;
					height: 35px;
					font-size: 14px;
				}

				.info-panel {
					left: 5px;
					right: 5px;
					bottom: 70px;
					font-size: 11px;
					max-height: 200px;
				}

				.info-panel h3 {
					font-size: 14px;
				}
			}
		</style>
	</head>
	<body>
		<div class="header">üåå Interactive 3D Solar System üåå</div>

		<button class="info-button" onclick="toggleInfoPopup()">‚ÑπÔ∏è</button>

		<div class="info-popup" id="info-popup">
			<button class="close-btn" onclick="closeInfoPopup()">√ó</button>
			<h3>About & Instructions</h3>
			<p><strong>Created by:</strong> A Senior 3D Graphics Programmer</p>
			<p>
				<strong>Scale Note:</strong> Distances compressed ~1000x for
				exploration purposes
			</p>
			<div style="margin: 15px 0">
				<h4 style="margin: 0 0 8px 0; color: #8af">How to Use:</h4>
				<p><strong>Desktop:</strong></p>
				<ul style="margin: 5px 0; padding-left: 20px">
					<li>Drag: Rotate view</li>
					<li>Shift + Drag (or Right-click + Drag): Pan camera</li>
					<li>Double-click: Show planet information</li>
					<li>Right-click: Travel to location</li>
					<li>Mouse wheel: Zoom in/out</li>
				</ul>
				<p><strong>Mobile:</strong></p>
				<ul style="margin: 5px 0; padding-left: 20px">
					<li>Single-tap drag: Rotate view</li>
					<li>Double-tap: Show planet information</li>
					<li>Long-press: Travel to location</li>
					<li>Pinch: Zoom in/out</li>
				</ul>
			</div>
			<p>
				<strong>Tip:</strong> Use the "Focus" buttons to center on planets, or click "Free Roam" to explore space freely!
			</p>
		</div>

		<div class="left-controls">
			<div class="time-controls">
				<h4>Time Control</h4>
				<button id="pause">Pause</button>
				<button id="slow">0.5x</button>
				<button id="normal" class="active">1x</button>
				<button id="fast">2x</button>
				<button id="faster">5x</button>
				<div class="time-display">
					Speed: <span id="speed-display">1x</span>
				</div>
			</div>

			<div class="shadow-controls">
				<h4>Visual Options</h4>
				<div class="shadow-toggle">
					<input type="checkbox" id="shadows-toggle" checked />
					<label for="shadows-toggle">Realistic Shadows</label>
				</div>
			</div>

			<div class="zoom-controls">
				<button id="zoom-in">+</button>
				<button id="zoom-out">-</button>
			</div>
		</div>

		<div class="controls-panel">
			<button id="focus-sun">Focus on Sun</button>
			<button id="focus-earth">Focus on Earth</button>
			<button id="focus-moon">Focus on Moon</button>
			<button id="focus-mars">Focus on Mars</button>
			<button id="focus-jupiter">Focus on Jupiter</button>
			<button id="free-roam">Free Roam</button>
		</div>

		<div class="info-panel" id="info-panel">
			<button class="close-btn" onclick="closeInfoPanel()">√ó</button>
			<h3 id="info-title"></h3>
			<div id="info-content"></div>
		</div>

		<div class="distance-indicator">
			<div>Camera Distance: <span id="camera-distance">0</span> AU</div>
			<div>Target: <span id="camera-target">Free Roam</span></div>
		</div>

		<div class="long-press-indicator" id="long-press-indicator"></div>

		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/objects/Lensflare.js"></script>

		<!-- Sun shaders -->
		<script id="sun-vertex-shader" type="x-shader/x-vertex">
			varying vec2 vUv;
			varying vec3 vNormal;
			void main() {
				vUv = uv;
				vNormal = normalize(normalMatrix * normal);
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
			}
		</script>
		<script id="sun-fragment-shader" type="x-shader/x-fragment">
			uniform float uTime;
			uniform sampler2D uSunTexture;
			varying vec2 vUv;
			varying vec3 vNormal;

			vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }
			float snoise(vec2 v){ const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439); vec2 i  = floor(v + dot(v, C.yy) ); vec2 x0 = v -   i + dot(i, C.xx); vec2 i1; i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0); vec4 x12 = x0.xyxy + C.xxzz; x12.xy -= i1; i = mod(i, 289.0); vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 )); vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0); m = m*m ; m = m*m ; vec3 x = 2.0 * fract(p * C.www) - 1.0; vec3 h = abs(x) - 0.5; vec3 ox = floor(x + 0.5); vec3 a0 = x - ox; m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h ); vec3 g; g.x  = a0.x  * x0.x  + h.x  * x0.y; g.yz = a0.yz * x12.xz + h.yz * x12.yw; return 130.0 * dot(m, g); }

			float fbm(vec2 st) {
				float value = 0.0;
				float amplitude = .5;
				for (int i = 0; i < 5; i++) {
					value += amplitude * snoise(st);
					st *= 2.;
					amplitude *= .5;
				}
				return value;
			}

			void main() {
				vec2 distortedUv = vUv;
				float distortionX = snoise(vUv * 4.0 + uTime * 0.1) * 0.02;
				float distortionY = snoise(vUv * 4.0 + uTime * 0.1 + vec2(5.2, 3.1)) * 0.02;
				distortedUv += vec2(distortionX, distortionY);
				vec3 baseColor = texture2D(uSunTexture, distortedUv).rgb;
				float hotspotNoise = fbm(vUv * 8.0 + uTime * 0.4);
				hotspotNoise = smoothstep(0.6, 1.0, hotspotNoise);
				vec3 finalColor = baseColor + vec3(1.0, 0.9, 0.5) * hotspotNoise;
				float rim = 1.0 - dot(normalize(vNormal), vec3(0.0, 0.0, 1.0));
				rim = pow(smoothstep(0.0, 1.0, rim), 2.0);
				finalColor += vec3(1.0, 0.7, 0.2) * rim * 1.5;
				gl_FragColor = vec4(finalColor, 1.0);
			}
		</script>

		<!-- Earth shaders -->
		<script id="earth-vertex-shader" type="x-shader/x-vertex">
			varying vec2 vUv;
			varying vec3 vWorldNormal;
			varying vec3 vWorldPosition;

			void main() {
				vUv = uv;
				vec4 worldPosition = modelMatrix * vec4(position, 1.0);
				vWorldPosition = worldPosition.xyz;
				vWorldNormal = normalize(mat3(modelMatrix) * normal);
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
			}
		</script>
		<script id="earth-fragment-shader" type="x-shader/x-fragment">
			uniform sampler2D uDayTexture;
			uniform sampler2D uNightTexture;
			uniform vec3 uSunDirection;
			uniform bool uShadowsEnabled;

			varying vec2 vUv;
			varying vec3 vWorldNormal;
			varying vec3 vWorldPosition;

			void main() {
				vec3 dayColor = texture2D(uDayTexture, vUv).rgb;
				vec3 nightColor = texture2D(uNightTexture, vUv).rgb;

				if (uShadowsEnabled) {
					float lightIntensity = dot(vWorldNormal, uSunDirection);
					float dayNightMixFactor = smoothstep(-0.15, 0.25, lightIntensity);
					vec3 finalColor = mix(nightColor * vec3(1.8, 1.2, 0.7), dayColor, dayNightMixFactor);
					gl_FragColor = vec4(finalColor, 1.0);
				} else {
					// No shadows - show the full planet with slight night glow
					vec3 finalColor = dayColor + nightColor * 0.3;
					gl_FragColor = vec4(finalColor, 1.0);
				}
			}
		</script>

		<script>
			// Constants
			const EARTH_RADIUS = 1,
				EARTH_ROTATION_SPEED = 0.0005,
				EARTH_ORBIT_SPEED = 0.0002;
			const MOON_RADIUS = 0.27,
				MOON_ORBIT_RADIUS = 60;
			const MARS_RADIUS = 0.53,
				MARS_ORBIT_RADIUS = 75,
				MARS_ROTATION_SPEED = 0.00045,
				MARS_ORBIT_SPEED = 0.0001;
			const JUPITER_RADIUS = 11,
				JUPITER_ORBIT_RADIUS = 260,
				JUPITER_ROTATION_SPEED = 0.001,
				JUPITER_ORBIT_SPEED = 0.000017;
			const SUN_RADIUS = 5,
				SUN_DISTANCE = 50;

			// Scale: 1 unit = 1 AU (Astronomical Unit)
			const AU_TO_UNITS = 1;
			const UNITS_TO_AU = 1;

			// Long press configuration
			const LONG_PRESS_DURATION = 600; // milliseconds
			const LONG_PRESS_MOVE_THRESHOLD = 10; // pixels

			// Double tap configuration
			const DOUBLE_TAP_DURATION = 300; // milliseconds
			const DOUBLE_TAP_DISTANCE_THRESHOLD = 20; // pixels

			// Global state variables
			let scene, camera, renderer, controls, clock, raycaster, mouse;
			let earth,
				moon,
				moonOrbitPivot,
				sun,
				mars,
				marsOrbitPivot,
				jupiter,
				jupiterOrbitPivot,
				starfield;
			let timeMultiplier = 1;
			let isAnimationPaused = false;
			let shadowsEnabled = true;

			// Long press state
			let longPressTimer = null;
			let longPressStartPos = { x: 0, y: 0 };
			let longPressCurrentPos = { x: 0, y: 0 };
			let isLongPressing = false;
			let longPressIndicator = null;

			// Double tap state
			let lastTapTime = 0;
			let lastTapPosition = { x: 0, y: 0 };
			let doubleTapTimer = null;

			// Continuous zoom state
			let zoomInterval = null;
			let isZooming = false;

			// Travel system
			let travelTarget = null;
			let isTraveling = false;
			let travelProgress = 0;
			let travelStartPosition = new THREE.Vector3();
			let travelStartTarget = new THREE.Vector3();
			let travelEndPosition = new THREE.Vector3();
			let travelEndTarget = new THREE.Vector3();

			let focusState = {
				isTransitioning: false,
				targetObject: null,
				targetDistance: 0,
				currentMode: "free",
				transitionSpeed: 0.05,
			};

			// Camera configurations
			const cameraConfigs = {
				sun: {
					distance: 25,
					minDistance: 15,
					maxDistance: 100,
					rotateSpeed: 0.3,
					zoomSpeed: 0.8,
				},
				earth: {
					distance: 2,
					minDistance: 3,
					maxDistance: 30,
					rotateSpeed: 0.5,
					zoomSpeed: 1.0,
				},
				moon: {
					distance: 2,
					minDistance: 1,
					maxDistance: 25,
					rotateSpeed: 0.8,
					zoomSpeed: 1.2,
				},
				mars: {
					distance: 3,
					minDistance: 2,
					maxDistance: 25,
					rotateSpeed: 0.5,
					zoomSpeed: 1.0,
				},
				jupiter: {
					distance: 25,
					minDistance: 15,
					maxDistance: 80,
					rotateSpeed: 0.3,
					zoomSpeed: 0.8,
				},
				free: {
					distance: 50,
					minDistance: 0.1,
					maxDistance: 200,
					rotateSpeed: 0.5,
					zoomSpeed: 1.0,
				},
			};

			// Child-friendly object information database
			const objectInfo = {
				sun: {
					name: "The Sun ‚òÄÔ∏è",
					type: "A Giant Ball of Fire",
					size: "SO big that 1 million Earths could fit inside!",
					temperature:
						"Really, REALLY hot! Much hotter than an oven!",
					distance: "Right in the middle of our solar system",
					color: "Yellow and orange like a giant campfire",
					funFact:
						"The Sun is like a giant lightbulb that lights up our whole planet!",
					description:
						"The Sun is our very own star! It's like a huge ball of fire that gives us light during the day and keeps us warm. Without the Sun, Earth would be dark and cold like a freezer!",
				},
				earth: {
					name: "Earth üåç",
					type: "Our Home Planet",
					size: "Just the right size for us to live on!",
					temperature: "Not too hot, not too cold - just perfect!",
					distance: "The perfect distance from the Sun",
					color: "Blue and green - blue oceans and green forests",
					funFact:
						"Earth is the only planet we know of that has animals, plants, and people!",
					description:
						"Earth is our amazing home! It has big blue oceans where fish live, green forests where animals play, and lots of different places to explore. It's the only planet we know of that has life!",
				},
				moon: {
					name: "The Moon üåô",
					type: "Earth's Best Friend",
					size: "About 4 times smaller than Earth",
					temperature: "Very cold at night, very hot during the day",
					distance: "About 30 Earths away from us",
					color: "Gray like a big rock, but it glows at night!",
					funFact:
						"The Moon changes shape every night! Sometimes it's round, sometimes it's a crescent!",
					description:
						"The Moon is Earth's best friend in space! It travels around Earth and lights up our night sky. People have even visited the Moon in spaceships! It has no air, so astronauts need special suits to breathe there.",
				},
				mars: {
					name: "Mars üî¥",
					type: "The Red Planet",
					size: "About half the size of Earth",
					temperature: "Much colder than Earth - like Antarctica!",
					distance: "Much farther from the Sun than Earth",
					color: "Red like rust or like a red crayon!",
					funFact:
						"Mars is red because it's covered in rusty dust, just like an old bicycle left outside!",
					description:
						"Mars is called the Red Planet because it looks red from far away! It's covered in red dust and has the biggest mountain in our whole solar system. Scientists are looking for signs that tiny creatures might have lived there long, long ago!",
				},
				jupiter: {
					name: "Jupiter ü™ê",
					type: "The Giant Planet",
					size: "HUGE! 11 times bigger than Earth - it's like a giant ball!",
					temperature: "Very cold - much colder than a freezer!",
					distance: "Much, much farther from the Sun than Earth",
					color: "Orange and brown with swirling stripes like a marble!",
					funFact:
						"Jupiter is so big that all the other planets could fit inside it with room to spare!",
					description:
						"Jupiter is the biggest planet in our solar system! It's like a giant ball of gas with beautiful swirling clouds. It spins super fast - a day on Jupiter is only 10 hours! It has a big red spot that's actually a huge storm bigger than Earth!",
				},
			};

			function init() {
				scene = new THREE.Scene();
				clock = new THREE.Clock();
				raycaster = new THREE.Raycaster();
				mouse = new THREE.Vector2();
				longPressIndicator = document.getElementById(
					"long-press-indicator"
				);

				camera = new THREE.PerspectiveCamera(
					60,
					window.innerWidth / window.innerHeight,
					0.01,
					10000
				);
				camera.position.set(3, 1, 3);

				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setPixelRatio(window.devicePixelRatio);
				document.body.appendChild(renderer.domElement);

				const textureLoader = new THREE.TextureLoader();

				// Create starfield background
				createStarfield(textureLoader);

				// --- Sun & Lights ---
				const sunGeometry = new THREE.SphereGeometry(
					SUN_RADIUS,
					64,
					64
				);
				const sunMaterial = new THREE.ShaderMaterial({
					uniforms: {
						uTime: { value: 0 },
						uSunTexture: {
							value: textureLoader.load("textures/2k_sun.jpg"),
						},
					},
					vertexShader:
						document.getElementById("sun-vertex-shader")
							.textContent,
					fragmentShader: document.getElementById(
						"sun-fragment-shader"
					).textContent,
				});
				sun = new THREE.Mesh(sunGeometry, sunMaterial);
				sun.position.z = -SUN_DISTANCE;
				sun.userData = { type: "sun" };
				scene.add(sun);

				const pointLight = new THREE.PointLight(0xffffff, 1.9, 2000);
				sun.add(pointLight);

				const ambientLight = new THREE.AmbientLight(0xffffff, 0.05);
				scene.add(ambientLight);

				// --- Earth ---
				const earthGeometry = new THREE.SphereGeometry(
					EARTH_RADIUS,
					64,
					64
				);
				const earthMaterial = new THREE.ShaderMaterial({
					vertexShader: document.getElementById("earth-vertex-shader")
						.textContent,
					fragmentShader: document.getElementById(
						"earth-fragment-shader"
					).textContent,
					uniforms: {
						uDayTexture: {
							value: textureLoader.load(
								"textures/2k_earth_daymap.jpg"
							),
						},
						uNightTexture: {
							value: textureLoader.load(
								"textures/2k_earth_nightmap.jpg"
							),
						},
						uSunDirection: { value: new THREE.Vector3(0, 0, 1) },
						uShadowsEnabled: { value: true },
					},
				});
				earth = new THREE.Mesh(earthGeometry, earthMaterial);
				earth.userData = { type: "earth" };
				scene.add(earth);

				// --- Moon ---
				moonOrbitPivot = new THREE.Object3D();
				earth.add(moonOrbitPivot);
				const moonGeometry = new THREE.SphereGeometry(
					MOON_RADIUS,
					32,
					32
				);
				const moonTexture = textureLoader.load("textures/2k_moon.jpg");
				const moonMaterial = new THREE.MeshPhongMaterial({
					map: moonTexture,
					emissiveMap: moonTexture,
					emissive: 0xffffff,
					emissiveIntensity: 0.07,
					shininess: 0,
					color: 0xbbbbbb,
				});
				moon = new THREE.Mesh(moonGeometry, moonMaterial);
				moon.position.x = MOON_ORBIT_RADIUS;
				moon.userData = { type: "moon" };
				moonOrbitPivot.add(moon);

				// --- Mars ---
				marsOrbitPivot = new THREE.Object3D();
				sun.add(marsOrbitPivot);
				const marsGeometry = new THREE.SphereGeometry(
					MARS_RADIUS,
					32,
					32
				);
				const marsTexture = textureLoader.load("textures/2k_mars.jpg");
				const marsMaterial = new THREE.MeshPhongMaterial({
					map: marsTexture,
					emissiveMap: marsTexture,
					emissive: 0xffffff,
					emissiveIntensity: 0.06,
					shininess: 0,
					color: 0xbbbbbb,
				});
				mars = new THREE.Mesh(marsGeometry, marsMaterial);
				mars.position.x = MARS_ORBIT_RADIUS;
				mars.userData = { type: "mars" };
				marsOrbitPivot.add(mars);

				// --- Jupiter ---
				jupiterOrbitPivot = new THREE.Object3D();
				sun.add(jupiterOrbitPivot);
				const jupiterGeometry = new THREE.SphereGeometry(
					JUPITER_RADIUS,
					64,
					64
				);
				const jupiterTexture = textureLoader.load(
					"textures/2k_jupiter.jpg"
				);
				const jupiterMaterial = new THREE.MeshPhongMaterial({
					map: jupiterTexture,
					emissiveMap: jupiterTexture,
					emissive: 0xffffff,
					emissiveIntensity: 0.05,
					shininess: 0,
					color: 0xbbbbbb,
				});
				jupiter = new THREE.Mesh(jupiterGeometry, jupiterMaterial);
				jupiter.position.x = JUPITER_ORBIT_RADIUS;
				jupiter.userData = { type: "jupiter" };
				jupiterOrbitPivot.add(jupiter);

				// Create orbital paths
				createOrbitalPaths();

				setupControls();
				setupEventListeners();
				setFocus("earth", earth);

				window.addEventListener("resize", onWindowResize, false);
				animate();
			}

			function createStarfield(textureLoader) {
				const starGeometry = new THREE.SphereGeometry(5000, 64, 64); // Larger sphere for far zoom
				const starTexture = textureLoader.load(
					"textures/2k_stars_milky_way.jpg"
				);

				// Tile the texture to create a bigger starfield
				starTexture.wrapS = THREE.RepeatWrapping;
				starTexture.wrapT = THREE.RepeatWrapping;
				starTexture.repeat.set(4, 4); // Repeat 4x4 = 16 times total

				const starMaterial = new THREE.MeshBasicMaterial({
					map: starTexture,
					side: THREE.BackSide,
					fog: false,
					depthWrite: false,
				});
				starfield = new THREE.Mesh(starGeometry, starMaterial);
				scene.add(starfield);
			}

			function createOrbitalPaths() {
				// Moon orbital path around Earth
				const moonOrbitGeometry = new THREE.RingGeometry(
					MOON_ORBIT_RADIUS - 0.02,
					MOON_ORBIT_RADIUS + 0.02,
					64
				);
				const moonOrbitMaterial = new THREE.MeshBasicMaterial({
					color: 0x888888,
					transparent: true,
					opacity: 0.15,
					side: THREE.DoubleSide,
				});
				const moonOrbitPath = new THREE.Mesh(
					moonOrbitGeometry,
					moonOrbitMaterial
				);
				moonOrbitPath.rotation.x = Math.PI / 2;
				earth.add(moonOrbitPath);

				// Mars orbital path around Sun
				const marsOrbitGeometry = new THREE.RingGeometry(
					MARS_ORBIT_RADIUS - 0.05,
					MARS_ORBIT_RADIUS + 0.05,
					128
				);
				const marsOrbitMaterial = new THREE.MeshBasicMaterial({
					color: 0xff6666,
					transparent: true,
					opacity: 0.12,
					side: THREE.DoubleSide,
				});
				const marsOrbitPath = new THREE.Mesh(
					marsOrbitGeometry,
					marsOrbitMaterial
				);
				marsOrbitPath.rotation.x = Math.PI / 2;
				sun.add(marsOrbitPath);

				// Jupiter orbital path around Sun
				const jupiterOrbitGeometry = new THREE.RingGeometry(
					JUPITER_ORBIT_RADIUS - 0.1,
					JUPITER_ORBIT_RADIUS + 0.1,
					128
				);
				const jupiterOrbitMaterial = new THREE.MeshBasicMaterial({
					color: 0xffa500,
					transparent: true,
					opacity: 0.08,
					side: THREE.DoubleSide,
				});
				const jupiterOrbitPath = new THREE.Mesh(
					jupiterOrbitGeometry,
					jupiterOrbitMaterial
				);
				jupiterOrbitPath.rotation.x = Math.PI / 2;
				sun.add(jupiterOrbitPath);

				// Earth orbital path around Sun
				const earthOrbitGeometry = new THREE.RingGeometry(
					SUN_DISTANCE - 0.05,
					SUN_DISTANCE + 0.05,
					128
				);
				const earthOrbitMaterial = new THREE.MeshBasicMaterial({
					color: 0x6666ff,
					transparent: true,
					opacity: 0.1,
					side: THREE.DoubleSide,
				});
				const earthOrbitPath = new THREE.Mesh(
					earthOrbitGeometry,
					earthOrbitMaterial
				);
				earthOrbitPath.rotation.x = Math.PI / 2;
				sun.add(earthOrbitPath);
			}

			function setupControls() {
				controls = new THREE.OrbitControls(camera, renderer.domElement);
				controls.enableDamping = true;
				controls.dampingFactor = 0.08;
				controls.screenSpacePanning = false;
				controls.maxPolarAngle = Math.PI;
				controls.minPolarAngle = 0;

				const config = cameraConfigs.free;
				controls.minDistance = config.minDistance;
				controls.maxDistance = config.maxDistance;
				controls.rotateSpeed = config.rotateSpeed;
				controls.zoomSpeed = config.zoomSpeed;
				controls.panSpeed = 0.5;
			}

			function setupEventListeners() {
				// Focus controls
				document
					.getElementById("focus-sun")
					.addEventListener("click", () => {
						setFocus("sun", sun);
					});
				document
					.getElementById("focus-earth")
					.addEventListener("click", () => {
						setFocus("earth", earth);
					});
				document
					.getElementById("focus-moon")
					.addEventListener("click", () => {
						setFocus("moon", moon);
					});
				document
					.getElementById("focus-mars")
					.addEventListener("click", () => {
						setFocus("mars", mars);
					});
				document
					.getElementById("focus-jupiter")
					.addEventListener("click", () => {
						setFocus("jupiter", jupiter);
					});
				document
					.getElementById("free-roam")
					.addEventListener("click", () => {
						setFreeRoam();
					});

				// Continuous zoom controls
				setupContinuousZoom();

				// Time controls
				document
					.getElementById("pause")
					.addEventListener("click", () => setTimeMultiplier(0));
				document
					.getElementById("slow")
					.addEventListener("click", () => setTimeMultiplier(0.5));
				document
					.getElementById("normal")
					.addEventListener("click", () => setTimeMultiplier(1));
				document
					.getElementById("fast")
					.addEventListener("click", () => setTimeMultiplier(2));
				document
					.getElementById("faster")
					.addEventListener("click", () => setTimeMultiplier(5));

				// Shadow toggle
				document
					.getElementById("shadows-toggle")
					.addEventListener("change", toggleShadows);

				// Desktop mouse events
				renderer.domElement.addEventListener("click", onMouseClick);
				renderer.domElement.addEventListener(
					"dblclick",
					onMouseDoubleClick
				);
				renderer.domElement.addEventListener(
					"contextmenu",
					onRightClick
				);
				renderer.domElement.addEventListener("mousemove", onMouseMove);
				renderer.domElement.addEventListener("mousedown", onMouseDown);
				renderer.domElement.addEventListener("mouseup", onMouseUp);

				// Touch events for mobile
				renderer.domElement.addEventListener(
					"touchstart",
					onTouchStart,
					{ passive: false }
				);
				renderer.domElement.addEventListener("touchmove", onTouchMove, {
					passive: false,
				});
				renderer.domElement.addEventListener("touchend", onTouchEnd, {
					passive: false,
				});

				// Prevent context menu on right click
				renderer.domElement.addEventListener("contextmenu", (e) =>
					e.preventDefault()
				);

				// Allow mouse wheel zoom
				renderer.domElement.addEventListener("wheel", onMouseWheel, {
					passive: false,
				});
			}

			function toggleShadows() {
				shadowsEnabled =
					document.getElementById("shadows-toggle").checked;

				// Update Earth shader
				earth.material.uniforms.uShadowsEnabled.value = shadowsEnabled;

				// Update other planets' emissive intensity
				if (shadowsEnabled) {
					moon.material.emissiveIntensity = 0.07;
					mars.material.emissiveIntensity = 0.06;
					jupiter.material.emissiveIntensity = 0.05;
				} else {
					// Make planets brighter when shadows are off
					moon.material.emissiveIntensity = 0.4;
					mars.material.emissiveIntensity = 0.4;
					jupiter.material.emissiveIntensity = 0.3;
				}
			}

			function setupContinuousZoom() {
				const zoomInBtn = document.getElementById("zoom-in");
				const zoomOutBtn = document.getElementById("zoom-out");

				// Mouse events for zoom in button
				zoomInBtn.addEventListener("mousedown", (e) => {
					e.preventDefault();
					startContinuousZoom(-0.05);
				});

				zoomInBtn.addEventListener("mouseup", stopContinuousZoom);
				zoomInBtn.addEventListener("mouseleave", stopContinuousZoom);

				// Mouse events for zoom out button
				zoomOutBtn.addEventListener("mousedown", (e) => {
					e.preventDefault();
					startContinuousZoom(0.05);
				});

				zoomOutBtn.addEventListener("mouseup", stopContinuousZoom);
				zoomOutBtn.addEventListener("mouseleave", stopContinuousZoom);

				// Touch events for zoom in button
				zoomInBtn.addEventListener("touchstart", (e) => {
					e.preventDefault();
					startContinuousZoom(-0.05);
				});

				zoomInBtn.addEventListener("touchend", (e) => {
					e.preventDefault();
					stopContinuousZoom();
				});

				// Touch events for zoom out button
				zoomOutBtn.addEventListener("touchstart", (e) => {
					e.preventDefault();
					startContinuousZoom(0.05);
				});

				zoomOutBtn.addEventListener("touchend", (e) => {
					e.preventDefault();
					stopContinuousZoom();
				});
			}

			function startContinuousZoom(delta) {
				if (isZooming) return;

				isZooming = true;

				// Immediate zoom
				zoomCamera(delta);

				// Start continuous zoom after a short delay
				setTimeout(() => {
					if (isZooming) {
						zoomInterval = setInterval(() => {
							if (isZooming) {
								zoomCamera(delta);
							}
						}, 50);
					}
				}, 200);
			}

			function stopContinuousZoom() {
				isZooming = false;
				if (zoomInterval) {
					clearInterval(zoomInterval);
					zoomInterval = null;
				}
			}

			// Info popup functions
			function toggleInfoPopup() {
				const popup = document.getElementById("info-popup");
				if (
					popup.style.display === "none" ||
					popup.style.display === ""
				) {
					popup.style.display = "block";
				} else {
					popup.style.display = "none";
				}
			}

			function closeInfoPopup() {
				document.getElementById("info-popup").style.display = "none";
			}

			// Global functions
			window.toggleInfoPopup = toggleInfoPopup;
			window.closeInfoPopup = closeInfoPopup;

			// Mouse event handlers
			function onMouseMove(event) {
				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
			}

			function onMouseDown(event) {
				if (event.button === 0) {
					startLongPress(event.clientX, event.clientY);
				}
			}

			function onMouseUp(event) {
				if (event.button === 0) {
					endLongPress();
				}
			}

			function onMouseClick(event) {
				if (event.button === 0) {
					// Single click - let orbit controls handle it naturally
				}
			}

			function onMouseDoubleClick(event) {
				// Desktop double-click for info panels
				handleInfoRequest(event.clientX, event.clientY);
			}

			function onRightClick(event) {
				event.preventDefault();
				travelToClickPoint(event.clientX, event.clientY);
			}

			function onMouseWheel(event) {
				event.preventDefault();
				const delta = event.deltaY > 0 ? 0.15 : -0.15;
				zoomCamera(delta);
			}

			// Touch event handlers
			function onTouchStart(event) {
				event.preventDefault();
				if (event.touches.length === 1) {
					const touch = event.touches[0];
					startLongPress(touch.clientX, touch.clientY);
				}
			}

			function onTouchMove(event) {
				event.preventDefault();
				if (event.touches.length === 1 && isLongPressing) {
					const touch = event.touches[0];
					longPressCurrentPos.x = touch.clientX;
					longPressCurrentPos.y = touch.clientY;

					const distance = Math.sqrt(
						Math.pow(
							longPressCurrentPos.x - longPressStartPos.x,
							2
						) +
							Math.pow(
								longPressCurrentPos.y - longPressStartPos.y,
								2
							)
					);

					if (distance > LONG_PRESS_MOVE_THRESHOLD) {
						endLongPress();
					}
				}
			}

			function onTouchEnd(event) {
				event.preventDefault();
				if (event.changedTouches.length === 1) {
					const touch = event.changedTouches[0];
					if (isLongPressing) {
						endLongPress();
					} else {
						handleTouchTap(touch.clientX, touch.clientY);
					}
				}
			}

			// Improved double-tap detection for touch
			function handleTouchTap(x, y) {
				const currentTime = Date.now();
				const timeDiff = currentTime - lastTapTime;

				// Check if this could be a double tap
				if (timeDiff < DOUBLE_TAP_DURATION && lastTapTime > 0) {
					const distance = Math.sqrt(
						Math.pow(x - lastTapPosition.x, 2) +
							Math.pow(y - lastTapPosition.y, 2)
					);

					if (distance < DOUBLE_TAP_DISTANCE_THRESHOLD) {
						// This is a double tap - show info panel
						handleInfoRequest(x, y);
						// Reset state
						lastTapTime = 0;
						lastTapPosition = { x: 0, y: 0 };
						if (doubleTapTimer) {
							clearTimeout(doubleTapTimer);
							doubleTapTimer = null;
						}
						return;
					}
				}

				// Record this tap
				lastTapTime = currentTime;
				lastTapPosition.x = x;
				lastTapPosition.y = y;

				// Clear any existing timer
				if (doubleTapTimer) {
					clearTimeout(doubleTapTimer);
				}

				// Set timer for single tap
				doubleTapTimer = setTimeout(() => {
					// Single tap - orbit controls handle navigation
					lastTapTime = 0;
					lastTapPosition = { x: 0, y: 0 };
					doubleTapTimer = null;
				}, DOUBLE_TAP_DURATION);
			}

			// Unified info request handler
			function handleInfoRequest(x, y) {
				mouse.x = (x / window.innerWidth) * 2 - 1;
				mouse.y = -(y / window.innerHeight) * 2 + 1;

				raycaster.setFromCamera(mouse, camera);
				const intersects = raycaster.intersectObjects([
					sun,
					earth,
					moon,
					mars,
					jupiter,
				]);

				if (intersects.length > 0) {
					const clickedObject = intersects[0].object;
					const objectType = clickedObject.userData.type;

					if (objectType && objectInfo[objectType]) {
						showInfoPanel(objectType);
					}
				}
			}

			// Long press functionality
			function startLongPress(x, y) {
				longPressStartPos.x = x;
				longPressStartPos.y = y;
				longPressCurrentPos.x = x;
				longPressCurrentPos.y = y;
				isLongPressing = true;

				longPressIndicator.style.left = x + "px";
				longPressIndicator.style.top = y + "px";
				longPressIndicator.style.width = "10px";
				longPressIndicator.style.height = "10px";
				longPressIndicator.style.display = "block";

				let progress = 0;
				const animateIndicator = () => {
					if (!isLongPressing) return;

					progress += 16;
					const size = 10 + (progress / LONG_PRESS_DURATION) * 40;
					longPressIndicator.style.width = size + "px";
					longPressIndicator.style.height = size + "px";

					if (progress < LONG_PRESS_DURATION) {
						requestAnimationFrame(animateIndicator);
					}
				};
				requestAnimationFrame(animateIndicator);

				longPressTimer = setTimeout(() => {
					if (isLongPressing) {
						completeLongPress();
					}
				}, LONG_PRESS_DURATION);
			}

			function endLongPress() {
				if (longPressTimer) {
					clearTimeout(longPressTimer);
					longPressTimer = null;
				}

				isLongPressing = false;
				longPressIndicator.style.display = "none";
			}

			function completeLongPress() {
				if (navigator.vibrate) {
					navigator.vibrate(50);
				}

				travelToClickPoint(longPressStartPos.x, longPressStartPos.y);
				endLongPress();
			}

			function travelToClickPoint(clientX, clientY) {
				mouse.x = (clientX / window.innerWidth) * 2 - 1;
				mouse.y = -(clientY / window.innerHeight) * 2 + 1;

				raycaster.setFromCamera(mouse, camera);
				const intersects = raycaster.intersectObjects([
					sun,
					earth,
					moon,
					mars,
					jupiter,
				]);

				if (intersects.length > 0) {
					const clickedObject = intersects[0].object;
					const objectType = clickedObject.userData.type;

					if (objectType && cameraConfigs[objectType]) {
						if (focusState.currentMode !== "free") {
							setFocus(objectType, clickedObject);
							return;
						} else {
							const targetPosition = new THREE.Vector3();
							clickedObject.getWorldPosition(targetPosition);

							const objectRadius =
								clickedObject.geometry.parameters.radius;
							const travelDistance = objectRadius * 8;

							const direction = new THREE.Vector3()
								.subVectors(camera.position, targetPosition)
								.normalize();
							const idealPosition = targetPosition
								.clone()
								.add(direction.multiplyScalar(travelDistance));

							travelToPoint(idealPosition, targetPosition);
							return;
						}
					}
				}

				if (focusState.currentMode === "free") {
					const clickPoint = new THREE.Vector3();
					const currentDistance = camera.position.distanceTo(
						controls.target
					);
					const travelDistance = Math.min(currentDistance * 2, 100);

					raycaster.ray.at(travelDistance, clickPoint);
					travelToPoint(clickPoint);
				}
			}

			function travelToPoint(targetPoint, optionalTarget = null) {
				if (isTraveling) return;

				isTraveling = true;
				travelProgress = 0;

				travelStartPosition.copy(camera.position);
				travelStartTarget.copy(controls.target);

				const direction = new THREE.Vector3()
					.subVectors(targetPoint, camera.position)
					.normalize();
				const distance = camera.position.distanceTo(targetPoint);
				const optimalDistance = Math.min(distance * 0.6, 30);

				travelEndPosition
					.copy(targetPoint)
					.add(direction.multiplyScalar(-optimalDistance));

				if (optionalTarget) {
					travelEndTarget.copy(optionalTarget);
				} else {
					travelEndTarget.copy(targetPoint);
				}

				controls.enabled = false;
			}

			function updateTravelSystem() {
				if (!isTraveling) return;

				travelProgress += 0.025;

				if (travelProgress >= 1) {
					travelProgress = 1;
					isTraveling = false;
					controls.enabled = true;
				}

				const easeProgress = 1 - Math.pow(1 - travelProgress, 3);

				camera.position.lerpVectors(
					travelStartPosition,
					travelEndPosition,
					easeProgress
				);
				controls.target.lerpVectors(
					travelStartTarget,
					travelEndTarget,
					easeProgress
				);
			}

			function zoomCamera(delta) {
				if (focusState.targetObject) {
					const currentDistance = camera.position.distanceTo(
						controls.target
					);
					const zoomAmount =
						delta * Math.max(currentDistance * 0.15, 0.5);
					const newDistance = currentDistance + zoomAmount;

					const clampedDistance = Math.max(
						controls.minDistance,
						Math.min(controls.maxDistance, newDistance)
					);

					focusState.targetDistance = clampedDistance;

					const direction = new THREE.Vector3()
						.subVectors(camera.position, controls.target)
						.normalize();
					const newPosition = controls.target
						.clone()
						.add(direction.multiplyScalar(clampedDistance));
					camera.position.copy(newPosition);
				} else {
					const direction = new THREE.Vector3()
						.subVectors(camera.position, controls.target)
						.normalize();
					const currentDistance = camera.position.distanceTo(
						controls.target
					);
					const zoomAmount =
						delta * Math.max(currentDistance * 0.15, 0.5);
					const newPosition = camera.position
						.clone()
						.add(direction.multiplyScalar(zoomAmount));

					const newDistance = newPosition.distanceTo(controls.target);
					if (
						newDistance >= controls.minDistance &&
						newDistance <= controls.maxDistance
					) {
						camera.position.copy(newPosition);
					} else {
						if (newDistance < controls.minDistance) {
							const limitPosition = controls.target
								.clone()
								.add(
									direction.multiplyScalar(
										controls.minDistance
									)
								);
							camera.position.copy(limitPosition);
						} else if (newDistance > controls.maxDistance) {
							const limitPosition = controls.target
								.clone()
								.add(
									direction.multiplyScalar(
										controls.maxDistance
									)
								);
							camera.position.copy(limitPosition);
						}
					}
				}
			}

			function setTimeMultiplier(multiplier) {
				timeMultiplier = multiplier;
				isAnimationPaused = multiplier === 0;

				document
					.querySelectorAll(".time-controls button")
					.forEach((btn) => {
						btn.classList.remove("active");
					});

				const speedText =
					multiplier === 0 ? "Paused" : `${multiplier}x`;
				document.getElementById("speed-display").textContent =
					speedText;

				if (multiplier === 0)
					document.getElementById("pause").classList.add("active");
				else if (multiplier === 0.5)
					document.getElementById("slow").classList.add("active");
				else if (multiplier === 1)
					document.getElementById("normal").classList.add("active");
				else if (multiplier === 2)
					document.getElementById("fast").classList.add("active");
				else if (multiplier === 5)
					document.getElementById("faster").classList.add("active");
			}

			function showInfoPanel(objectType) {
				const panel = document.getElementById("info-panel");
				const title = document.getElementById("info-title");
				const content = document.getElementById("info-content");

				const info = objectInfo[objectType];
				title.textContent = info.name;
				content.innerHTML = `
					<div style="margin-bottom: 10px;">
						<p><strong>What is it?</strong> ${info.type}</p>
						<p><strong>How big is it?</strong> ${info.size}</p>
						<p><strong>How hot or cold?</strong> ${info.temperature}</p>
						<p><strong>What color is it?</strong> ${info.color}</p>
						<p><strong>Where is it?</strong> ${info.distance}</p>
					</div>
					<div style="background-color: rgba(136, 170, 255, 0.2); padding: 10px; border-radius: 5px; margin-bottom: 10px;">
						<p><strong>üåü Cool Fact:</strong> ${info.funFact}</p>
					</div>
					<div>
						<p><strong>Tell me more!</strong></p>
						<p>${info.description}</p>
					</div>
				`;

				panel.style.display = "block";
			}

			function closeInfoPanel() {
				document.getElementById("info-panel").style.display = "none";
			}

			window.closeInfoPanel = closeInfoPanel;

			function setFocus(mode, object) {
				const config = cameraConfigs[mode];

				focusState.isTransitioning = true;
				focusState.targetObject = object;
				focusState.targetDistance = config.distance;
				focusState.currentMode = mode;

				controls.minDistance = config.minDistance;
				controls.maxDistance = config.maxDistance;
				controls.rotateSpeed = config.rotateSpeed;
				controls.zoomSpeed = config.zoomSpeed;
				controls.panSpeed = 0.3;

				controls.autoRotate = false;
				updateActiveButton(mode);
			}

			function setFreeRoam() {
				const config = cameraConfigs.free;

				focusState.isTransitioning = false;
				focusState.targetObject = null;
				focusState.currentMode = "free";

				controls.minDistance = config.minDistance;
				controls.maxDistance = config.maxDistance;
				controls.rotateSpeed = config.rotateSpeed;
				controls.zoomSpeed = config.zoomSpeed;
				controls.panSpeed = 0.8;
				controls.autoRotate = false;

				// Position controls.target in front of camera for true free roam
				const direction = new THREE.Vector3();
				camera.getWorldDirection(direction);
				controls.target.copy(camera.position).add(direction.multiplyScalar(50));

				updateActiveButton("free-roam");
			}

			function updateActiveButton(mode) {
				document
					.querySelectorAll(".controls-panel button")
					.forEach((btn) => {
						btn.classList.remove("active");
					});

				const buttonId =
					mode === "free" ? "free-roam" : `focus-${mode}`;
				const button = document.getElementById(buttonId);
				if (button) button.classList.add("active");
			}

			function updateFocusTransition() {
				if (!focusState.isTransitioning || !focusState.targetObject)
					return;

				const targetPosition = new THREE.Vector3();
				focusState.targetObject.getWorldPosition(targetPosition);

				const currentDirection = new THREE.Vector3()
					.subVectors(camera.position, controls.target)
					.normalize();

				if (currentDirection.length() < 0.001) {
					currentDirection.set(1, 0.5, 1).normalize();
				}

				const idealPosition = targetPosition
					.clone()
					.add(
						currentDirection.multiplyScalar(
							focusState.targetDistance
						)
					);

				const distanceToTarget =
					camera.position.distanceTo(idealPosition);
				const adaptiveSpeed = Math.min(
					0.1,
					focusState.transitionSpeed + distanceToTarget * 0.01
				);

				camera.position.lerp(idealPosition, adaptiveSpeed);
				controls.target.lerp(targetPosition, adaptiveSpeed);

				const positionThreshold = focusState.targetDistance * 0.05;
				const targetThreshold =
					focusState.targetObject.geometry.parameters.radius * 0.1;

				if (
					camera.position.distanceTo(idealPosition) <
						positionThreshold &&
					controls.target.distanceTo(targetPosition) < targetThreshold
				) {
					focusState.isTransitioning = false;
				}
			}

			function updateTrackingMode() {
				if (!focusState.targetObject || focusState.isTransitioning)
					return;

				const targetPosition = new THREE.Vector3();
				focusState.targetObject.getWorldPosition(targetPosition);

				controls.target.lerp(targetPosition, 0.02);
			}

			function updateDistanceIndicator() {
				const distance = camera.position.distanceTo(controls.target);
				const distanceInAU = (distance * UNITS_TO_AU).toFixed(2);

				document.getElementById("camera-distance").textContent =
					distanceInAU;

				let targetName = "Free Roam";
				if (focusState.targetObject) {
					const objectType = focusState.targetObject.userData.type;
					if (objectType && objectInfo[objectType]) {
						targetName = objectInfo[objectType].name;
					}
				}
				document.getElementById("camera-target").textContent =
					targetName;
			}

			function animate() {
				requestAnimationFrame(animate);
				const elapsedTime = clock.getElapsedTime();
				const delta = clock.getDelta();

				if (!isAnimationPaused) {
					const adjustedDelta = delta * timeMultiplier;

					sun.material.uniforms.uTime.value =
						elapsedTime * timeMultiplier;

					earth.rotateY(EARTH_ROTATION_SPEED * timeMultiplier);
					moonOrbitPivot.rotateY(EARTH_ORBIT_SPEED * timeMultiplier);
					marsOrbitPivot.rotateY(MARS_ORBIT_SPEED * timeMultiplier);
					mars.rotateY(MARS_ROTATION_SPEED * timeMultiplier);

					// Jupiter animation
					jupiterOrbitPivot.rotateY(
						JUPITER_ORBIT_SPEED * timeMultiplier
					);
					jupiter.rotateY(JUPITER_ROTATION_SPEED * timeMultiplier);

					if (starfield) {
						starfield.rotation.y += 0.00005 * timeMultiplier;
					}
				}

				if (starfield) {
					// starfield.position.copy(camera.position);
				}

				const sunWorldPosition = new THREE.Vector3();
				sun.getWorldPosition(sunWorldPosition);
				const earthWorldPosition = new THREE.Vector3();
				earth.getWorldPosition(earthWorldPosition);
				const sunDirection = new THREE.Vector3()
					.subVectors(sunWorldPosition, earthWorldPosition)
					.normalize();
				earth.material.uniforms.uSunDirection.value = sunDirection;

				updateFocusTransition();
				updateTrackingMode();
				updateTravelSystem();
				updateDistanceIndicator();

				// Dynamic starfield scaling to prevent black background
				const cameraDistance = camera.position.length();
				const minStarfieldSize = 5000;
				const starfieldScale = Math.max(
					minStarfieldSize,
					cameraDistance * 3
				);
				starfield.scale.setScalar(starfieldScale / 5000);

				controls.update();
				renderer.render(scene, camera);
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			document.addEventListener("DOMContentLoaded", function () {
				const zoomButtons = document.querySelectorAll(
					".zoom-controls button"
				);
				zoomButtons.forEach((button) => {
					button.addEventListener("selectstart", (e) =>
						e.preventDefault()
					);
					button.addEventListener("dragstart", (e) =>
						e.preventDefault()
					);
				});
			});

			init();
			renderer.setClearColor(0x000000);
		</script>
	</body>
</html>
